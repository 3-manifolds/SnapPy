cdef class OrbTriangulation:
    """

    >>> from snappy import Orb
    >>> o = Orb.OrbifoldTriangulation("ORB_FILE.orb")
    >>> o.retriangulate() # Recreates triangulation from diagram, forgets what user entered for singular locus

    """

    cdef c_Triangulation* c_triangulation
    cdef c_Diagram* c_diagram

    def __cinit__(self, spec=None, remove_finite_vertices=True):
        self.c_triangulation = NULL
        self.c_diagram = NULL

        for attr in [
                '_to_orb_string',
                '_to_snappea_string',
                '__snappy__',
                'snapPea',
                '_to_string']:
            if hasattr(spec, attr):
                spec = getattr(spec, attr)()
                break

        if spec is None:
            self.get_from_new_plink()
        elif spec == 'empty':
            pass
        else:
            if not isinstance(spec, (str, bytes)):
                raise TypeError("Expected str or bytes (TODO: fill in error")
            self.get_triangulation(
                spec, remove_finite_vertices=remove_finite_vertices)

            if self.c_triangulation == NULL:
                raise RuntimeError('An empty triangulation was generated.')

    def __dealloc__(self):
        if self.c_triangulation != NULL:
            free_triangulation(self.c_triangulation)
        if self.c_diagram != NULL:
            free_diagram(self.c_diagram)

    cdef get_from_new_plink(self, file_name=None):
        raise NotImplementedError("Orbifold PLink not implemented yet.")

    cdef get_triangulation(self, spec, remove_finite_vertices=True):
        if ( isinstance(spec, str) and spec.startswith('% Triangulation') or
             isinstance(spec, bytes) and spec.startswith(b'% Triangulation')):
            self._from_triangulation_string(
                spec, remove_finite_vertices=remove_finite_vertices)
            return
        if (isinstance(spec, str) and spec.startswith('% orb') or
            isinstance(spec, bytes) and spec.startswith(b'% orb')):
            self._from_orb_string(
                spec, remove_finite_vertices=remove_finite_vertices)

        self.get_from_file(spec, remove_finite_vertices)

    def _from_triangulation_string(self, string, remove_finite_vertices=True):
        """
        WARNING: Users should not use this function directly.  To
        create a Triangulation or Manifold or ManifoldHP from a string
        containing the contents of a triangulation file, simply do:

        >>> M = Manifold('7_4')
        >>> seed = M._to_string()
        >>> N = Manifold(seed)
        >>> N == M
        True

        Fill an empty Triangulation from a string generated by
        _to_string.
        """
        if self.c_triangulation is not NULL:
            raise ValueError('The Triangulation must be empty.')
        self.c_triangulation = read_triangulation_from_string(
            to_byte_str(string))
        if remove_finite_vertices:
            self._remove_finite_vertices()

    def _from_orb_string(self, string, remove_finite_vertices=True):
        if self.c_triangulation is not NULL:
            raise ValueError('The Triangulation must be empty.')
        if self.c_diagram is not NULL:
            raise ValueError('The diagram must be empty.')
        read_orb_from_string(
            to_byte_str(string), &self.c_triangulation, &self.c_diagram)
        if remove_finite_vertices:
            self._remove_finite_vertices()

    def get_from_file(self, name, remove_finite_vertices=True):
        locations = [os.curdir]
        env_var_name = 'SNAPPEA_MANIFOLD_DIRECTORY'
        location = os.environ.get(env_var_name)
        if location is not None:
            locations.append(location)
        for location in locations:
            path = os.path.join(location, name)
            if os.path.isfile(path):
                with open(path) as file:
                    first_line = file.readline()
                if first_line.startswith('% orb'):
                    read_orb(
                        to_byte_str(path),
                        &self.c_triangulation, &self.c_diagram)
                elif first_line.startswith('% Triangulation'):
                    self.c_triangulation = read_triangulation(to_byte_str(path))
                else:
                    raise IOError('File %s has unknown file format.' % name)
                break
        if self.c_triangulation == NULL:
            raise IOError(
                'The orbifold or manifold file %s was not found.' % name)
        if remove_finite_vertices:
            self._remove_finite_vertices()
            
    def _remove_finite_vertices(self):
        if self.c_triangulation == NULL:
            return
        remove_finite_vertices(self.c_triangulation)

    def _to_orb_string(self):
        cdef char *c_string
        cdef result
        if self.c_triangulation is NULL:
            raise ValueError('The Triangulation is empty.')

        try:
            c_string = write_orb_to_string(self.c_triangulation, self.c_diagram)
            result = c_string
        finally:
            free(c_string)
        return to_str(result)

    def _to_snappea_string(self):
        cdef char *c_string
        cdef result
        if self.c_triangulation is NULL:
            raise ValueError('The Triangulation is empty.')

        try:
            c_string = string_triangulation(self.c_triangulation)
            result = c_string
        finally:
            free(c_string)
        return to_str(result)

    def retriangulate_diagram(self):
        """
        Demo
        """

        if self.c_diagram == NULL:
            return False

        # TODO: fix memory leak

        self.c_triangulation = triangulate_diagram_complement(
            self.c_diagram, True)

        return True
